Для решения такого рода проблем нужен алгоритм, который дорого вычислять, но при этом дешево проверять. В данном случае я использовал алгоритм Hashcash, который решается перебором (хотя и можно делать эти вычисления параллельно). 
Плюсы:
1. Простой в реализации
2. Sha1 быстрее более безопасных алгоритмов хеширования


Минусы:
1. Sha1 устаревший алгоритм, который уязвим к коллизиям (можно заменить на более современные как sha256, hashx: https://github.com/tevador/hashx?tab=readme-ov-file#protocols-based-on-hashx  и тд)
2. Несбалансированный, те нагружает только CPU/GPU (в зависимости от реализации), но не нагружает память. (есть другие новые алгоритмы которые решают эту проблему, такие как https://github.com/tromp/cuckoo, построенные на поиске циклов в графах)
3. Решение перебором можно ускорить если использовать Grover's search algorithm, который сокращает сложность до O(√N)

В целом тема обширная и сложная, требует много времени для изучения, за выходные такое не сделаешь, поэтому я использовал наиболее простой и известный алгоритм в решении
